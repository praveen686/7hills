// Legacy crate - suppress clippy warnings pending migration
#![allow(clippy::collapsible_if)]
#![allow(clippy::collapsible_else_if)]
#![allow(clippy::redundant_pattern_matching)]
#![allow(clippy::new_without_default)]
#![allow(clippy::manual_strip)]
#![allow(clippy::needless_range_loop)]
#![allow(clippy::clone_on_copy)]
#![allow(clippy::too_many_arguments)]
#![allow(clippy::manual_is_multiple_of)]
#![allow(clippy::redundant_closure)]
#![allow(clippy::let_and_return)]
#![allow(clippy::derivable_impls)]

//! # QuantLaxmi Core Module
//!
//! Provides the central event bus and core abstractions for the trading system.
//!
//! ## Description
//! This crate implements the LMAX Disruptor-inspired event processing architecture.
//! It provides a high-performance, lock-free event bus for decoupling market data
//! ingestion, strategy execution, and order routing.
//!
//! ## Architecture
//! ```text
//! ┌─────────────┐    ┌──────────┐    ┌──────────────┐
//! │ Connectors  │───▶│ EventBus │───▶│  Strategies  │
//! └─────────────┘    └──────────┘    └──────────────┘
//!                         │                 │
//!                         ▼                 ▼
//!                    ┌──────────┐    ┌──────────────┐
//!                    │   WAL    │    │ Risk Engine  │
//!                    └──────────┘    └──────────────┘
//! ```
//!
//! ## Performance
//! - Event bus latency: ~230ns (MPSC channels)
//! - Broadcast capacity: Configurable (default 1024)
//!
//! ## Modules
//! - [`strategy`] - Trading strategy abstractions
//! - [`mode`] - Execution mode configuration (paper/live)
//! - [`portfolio`] - Position and PnL tracking
//! - [`connector`] - Market connector trait
//! - [`wal`] - Write-ahead logging for replay
//!
//! ## References
//! - LMAX Disruptor: <https://lmax-exchange.github.io/disruptor/>
//! - IEEE Std 1016-2009: Software Design Descriptions

use async_trait::async_trait;
use quantlaxmi_models::{FillEvent, OrderEvent, RiskEvent, SignalEvent, SystemHealthEvent};
// MarketEvent replaced by WalMarketRecord for canonical mantissa-based data
use std::sync::Arc;
use tokio::sync::broadcast;
use tracing::{info, warn};

pub mod aeon;
pub mod connector;
pub mod hydra;
pub mod lob;
pub mod metrics;
pub mod mode;
pub mod null_observer;
pub mod observability;
pub mod oras;
pub mod parquet_export;
pub mod portfolio;
pub mod rmt;
pub mod strategy;

pub use aeon::AeonStrategy;
pub use hydra::HydraStrategy;
pub use null_observer::{NullObserverStrategy, OptionChainReport};
pub use oras::OrasStrategy;
pub use strategy::{MomentumStrategy, Strategy, StrategyRunner};

pub use lob::{LevelDelta, LobError, OrderBook};
pub use metrics::{MetricsConfig, MetricsSnapshot, TradeRecord, TradingMetrics};
pub use mode::{ExecutionMode, ModeConfig};
pub use portfolio::Portfolio;

// Re-export canonical WAL types for consumers
pub use quantlaxmi_wal::{MarketPayload, WalManifest, WalMarketRecord};

/// Unified event container for the QuantLaxmi ecosystem.
///
/// # Description
/// Decouples event producers from consumers by wrapping all system signals
/// into a single strongly-typed enumeration. This promotes architectural
/// flexibility and simplifies logging/audit persistence.
pub enum Event {
    /// Incremental price or orderbook updates (canonical mantissa-based).
    Market(quantlaxmi_wal::WalMarketRecord),
    /// Alpha-driven signals generated by strategies.
    Signal(SignalEvent),
    /// Instructions for order placement, modification, or cancellation.
    Order(OrderEvent),
    /// Security or compliance violations flagged by the `RiskEngine`.
    Risk(RiskEvent),
    /// Diagnostic or operational status updates from internal services.
    Health(SystemHealthEvent),
    /// Verifiable trade execution records for post-trade analysis.
    Fill(FillEvent),
}

/// Central event bus for inter-component communication.
///
/// # Description
/// Implements a pub/sub architecture with separate channels for market data,
/// orders, signals, risk, and health events.
///
/// # Market Event Type
/// Uses `WalMarketRecord` (mantissa-based) instead of `MarketEvent` (float-based)
/// for deterministic cross-platform replay.
pub struct EventBus {
    /// Broadcast sender for market events (canonical mantissa-based WalMarketRecord).
    market_sender: broadcast::Sender<quantlaxmi_wal::WalMarketRecord>,
    /// Broadcast sender for signal events.
    signal_sender: broadcast::Sender<SignalEvent>,
    /// Broadcast sender for risk events.
    risk_sender: broadcast::Sender<RiskEvent>,
    /// Broadcast sender for system health events.
    health_sender: broadcast::Sender<SystemHealthEvent>,
    /// Broadcast sender for fill events.
    fill_sender: broadcast::Sender<FillEvent>,
    /// Broadcast sender for order instructions (from strategy to executor).
    order_sender: broadcast::Sender<OrderEvent>,
    /// Broadcast sender for order status updates (from executor/connector to strategy/monitor).
    order_update_sender: broadcast::Sender<OrderEvent>,

    /// Keep-alive handles.
    _market_handle: broadcast::Receiver<quantlaxmi_wal::WalMarketRecord>,
    _risk_handle: broadcast::Receiver<RiskEvent>,
    _health_handle: broadcast::Receiver<SystemHealthEvent>,
    _fill_handle: broadcast::Receiver<FillEvent>,
    _signal_handle: broadcast::Receiver<SignalEvent>,
    _order_handle: broadcast::Receiver<OrderEvent>,
    _order_update_handle: broadcast::Receiver<OrderEvent>,
}

impl EventBus {
    /// Creates a new event bus with specified market data capacity.
    pub fn new(capacity: usize) -> Arc<Self> {
        let (market_sender, _market_handle) = broadcast::channel(capacity);
        let (order_sender, _order_handle) = broadcast::channel(500);
        let (signal_sender, _signal_handle) = broadcast::channel(500);
        let (risk_sender, _risk_handle) = broadcast::channel(100);
        let (health_sender, _health_handle) = broadcast::channel(100);
        let (fill_sender, _fill_handle) = broadcast::channel(500);
        let (order_update_sender, _order_update_handle) = broadcast::channel(500);

        Arc::new(Self {
            market_sender,
            order_sender,
            signal_sender,
            risk_sender,
            health_sender,
            fill_sender,
            order_update_sender,
            _market_handle,
            _risk_handle,
            _health_handle,
            _fill_handle,
            _signal_handle,
            _order_handle,
            _order_update_handle,
        })
    }

    pub async fn publish_market(
        &self,
        event: quantlaxmi_wal::WalMarketRecord,
    ) -> anyhow::Result<()> {
        if let Err(e) = self.market_sender.send(event) {
            warn!("Market data channel lag or no subscribers: {}", e);
        }
        Ok(())
    }

    pub async fn publish_order(&self, event: OrderEvent) -> anyhow::Result<()> {
        if let Err(e) = self.order_sender.send(event) {
            warn!("Order channel lag or no executors: {}", e);
        }
        Ok(())
    }

    pub async fn publish_signal(&self, event: SignalEvent) -> anyhow::Result<()> {
        if let Err(e) = self.signal_sender.send(event) {
            warn!("Signal channel lag or no risk engine/monitor: {}", e);
        }
        Ok(())
    }

    pub fn publish_signal_sync(&self, event: SignalEvent) -> anyhow::Result<()> {
        let _ = self.signal_sender.send(event);
        Ok(())
    }

    pub async fn publish_risk(&self, event: RiskEvent) -> anyhow::Result<()> {
        if let Err(e) = self.risk_sender.send(event) {
            warn!("Risk event channel lag or no subscribers: {}", e);
        }
        Ok(())
    }

    pub async fn publish_health(&self, event: SystemHealthEvent) -> anyhow::Result<()> {
        if let Err(e) = self.health_sender.send(event) {
            warn!("Health event channel lag or no subscribers: {}", e);
        }
        Ok(())
    }

    pub async fn publish_fill(&self, event: FillEvent) -> anyhow::Result<()> {
        if let Err(e) = self.fill_sender.send(event) {
            warn!("Fill event channel lag or no subscribers: {}", e);
        }
        Ok(())
    }

    pub fn publish_order_update(&self, event: OrderEvent) -> anyhow::Result<()> {
        if let Err(e) = self.order_update_sender.send(event) {
            warn!("Order update channel lag or no subscribers: {}", e);
        }
        Ok(())
    }

    pub fn subscribe_market(&self) -> broadcast::Receiver<quantlaxmi_wal::WalMarketRecord> {
        self.market_sender.subscribe()
    }

    pub fn subscribe_risk(&self) -> broadcast::Receiver<RiskEvent> {
        self.risk_sender.subscribe()
    }

    pub fn subscribe_health(&self) -> broadcast::Receiver<SystemHealthEvent> {
        self.health_sender.subscribe()
    }

    pub fn subscribe_fill(&self) -> broadcast::Receiver<FillEvent> {
        self.fill_sender.subscribe()
    }

    pub fn subscribe_order_update(&self) -> broadcast::Receiver<OrderEvent> {
        self.order_update_sender.subscribe()
    }

    pub fn subscribe_signal(&self) -> broadcast::Receiver<SignalEvent> {
        self.signal_sender.subscribe()
    }

    pub fn subscribe_order(&self) -> broadcast::Receiver<OrderEvent> {
        self.order_sender.subscribe()
    }
}

// Legacy WAL module DELETED - use quantlaxmi_wal crate instead

// ============================================================================
// WAL-PERSISTENT EVENT BUS (using quantlaxmi-wal)
// ============================================================================

use quantlaxmi_wal::WalWriter;
pub use quantlaxmi_wal::{DecisionEvent, WalReader};
use std::path::{Path, PathBuf};
use std::sync::atomic::{AtomicBool, Ordering};

/// EventBus with WAL persistence via quantlaxmi-wal.
///
/// # Description
/// Wraps `EventBus` and uses `quantlaxmi_wal::WalWriter` to ensure all critical
/// events are synchronously persisted before being broadcast to subscribers.
/// This provides a durable audit trail required for compliance and
/// deterministic backtesting.
pub struct WalPersistentBus {
    /// Underlying high-performance event bus.
    bus: Arc<EventBus>,
    /// Async WAL writer (protected by async mutex for concurrent access).
    wal_writer: tokio::sync::Mutex<WalWriter>,
    /// Session directory path.
    session_dir: PathBuf,
    /// Finalization flag (idempotent shutdown).
    finalized: AtomicBool,
}

impl WalPersistentBus {
    /// Creates a new persistent event bus with WAL.
    ///
    /// # Parameters
    /// * `capacity` - Primary buffer size for market data broadcast.
    /// * `session_dir` - Session directory for WAL files.
    pub async fn new(capacity: usize, session_dir: &Path) -> anyhow::Result<Arc<Self>> {
        let wal_writer = WalWriter::new(session_dir).await?;
        Ok(Arc::new(Self {
            bus: EventBus::new(capacity),
            wal_writer: tokio::sync::Mutex::new(wal_writer),
            session_dir: session_dir.to_path_buf(),
            finalized: AtomicBool::new(false),
        }))
    }

    /// Persists and publishes a market data event.
    pub async fn publish_market(&self, event: WalMarketRecord) -> anyhow::Result<()> {
        // Persist first, then broadcast
        self.wal_writer
            .lock()
            .await
            .write_market(event.clone())
            .await?;
        self.bus.publish_market(event).await
    }

    /// Persists and publishes a decision event.
    pub async fn publish_decision(&self, event: DecisionEvent) -> anyhow::Result<()> {
        self.wal_writer.lock().await.write_decision(event).await?;
        Ok(())
    }

    /// Persists and publishes an order instruction.
    pub async fn publish_order(&self, event: OrderEvent) -> anyhow::Result<()> {
        self.wal_writer
            .lock()
            .await
            .write_order(event.clone())
            .await?;
        self.bus.publish_order(event).await
    }

    /// Persists and publishes a risk violation.
    pub async fn publish_risk(&self, event: RiskEvent) -> anyhow::Result<()> {
        self.wal_writer
            .lock()
            .await
            .write_risk(event.clone())
            .await?;
        self.bus.publish_risk(event).await
    }

    /// Persists and publishes a trade execution record.
    pub async fn publish_fill(&self, event: FillEvent) -> anyhow::Result<()> {
        self.wal_writer
            .lock()
            .await
            .write_fill(event.clone())
            .await?;
        self.bus.publish_fill(event).await
    }

    /// Publishes a health status update (not persisted to WAL).
    pub async fn publish_health(&self, event: SystemHealthEvent) -> anyhow::Result<()> {
        self.bus.publish_health(event).await
    }

    /// Publishes an order update (persisted as order event).
    pub async fn publish_order_update(&self, event: OrderEvent) -> anyhow::Result<()> {
        self.wal_writer
            .lock()
            .await
            .write_order(event.clone())
            .await?;
        self.bus.publish_order_update(event)
    }

    /// Forwards signal events directly to the bus (transient, not persisted).
    pub async fn publish_signal(&self, event: SignalEvent) -> anyhow::Result<()> {
        self.bus.publish_signal(event).await
    }

    /// Grants access to the underlying broadcast bus.
    pub fn inner(&self) -> &Arc<EventBus> {
        &self.bus
    }

    /// Provides the session directory path.
    pub fn session_dir(&self) -> &Path {
        &self.session_dir
    }

    pub fn subscribe_market(&self) -> broadcast::Receiver<WalMarketRecord> {
        self.bus.subscribe_market()
    }

    pub fn subscribe_risk(&self) -> broadcast::Receiver<RiskEvent> {
        self.bus.subscribe_risk()
    }

    pub fn subscribe_order_update(&self) -> broadcast::Receiver<OrderEvent> {
        self.bus.subscribe_order_update()
    }

    pub fn subscribe_signal(&self) -> broadcast::Receiver<SignalEvent> {
        self.bus.subscribe_signal()
    }

    pub fn subscribe_order(&self) -> broadcast::Receiver<OrderEvent> {
        self.bus.subscribe_order()
    }

    /// Shutdown and finalize the WAL, returning the manifest.
    /// Safe to call under Arc<Self>. Idempotent (second call returns error).
    pub async fn shutdown(&self) -> anyhow::Result<WalManifest> {
        if self.finalized.swap(true, Ordering::SeqCst) {
            anyhow::bail!("WalPersistentBus already finalized");
        }
        let mut writer = self.wal_writer.lock().await;
        let manifest = writer.finalize().await?;

        // Write manifest to session directory
        let manifest_path = self.session_dir.join("manifest.json");
        let manifest_json = serde_json::to_string_pretty(&manifest)?;
        tokio::fs::write(&manifest_path, manifest_json).await?;

        info!(
            "WAL finalized: {} market events, manifest written to {:?}",
            manifest.counts.market_events, manifest_path
        );

        Ok(manifest)
    }
}

// ============================================================================
// PAPER TRADING CONNECTOR
// ============================================================================

use crate::connector::MarketConnector;

/// Integration bridge for real-time market simulation.
///
/// # Description
/// Leverages the Decorator pattern to wrap any `MarketConnector`. It
/// diverts order flow from live venues while maintaining real-time
/// market data streams, creating an "Order Sandbox" for live-market simulation.
pub struct PaperTradingConnector<C: MarketConnector> {
    /// The live data source (e.g., Binance, Zerodha).
    live_connector: C,
    /// Destination bus for simulated results.
    bus: Arc<EventBus>,
    /// Internal state toggle.
    is_paper: bool,
}

impl<C: MarketConnector> PaperTradingConnector<C> {
    /// Wraps a live connector for paper trading.
    pub fn new(live_connector: C, bus: Arc<EventBus>) -> Self {
        Self {
            live_connector,
            bus,
            is_paper: true,
        }
    }

    pub fn is_paper_mode(&self) -> bool {
        self.is_paper
    }

    pub fn event_bus(&self) -> Arc<EventBus> {
        Arc::clone(&self.bus)
    }
}

#[async_trait]
impl<C: MarketConnector + Send + Sync> MarketConnector for PaperTradingConnector<C> {
    /// Proxies the startup signal to the underlying live venue.
    async fn run(&self) -> anyhow::Result<()> {
        info!("PaperTradingConnector: Starting with live market data, simulated fills");
        self.live_connector.run().await
    }

    fn stop(&self) {
        self.live_connector.stop();
    }

    fn name(&self) -> &'static str {
        "PaperTrading"
    }
}
