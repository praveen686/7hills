// This file is @generated by prost-build.
/// ──────────────────────────────────────────────
/// Fixed-point representation (deterministic, no FP drift)
/// ──────────────────────────────────────────────
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FixedPoint {
    #[prost(int64, tag = "1")]
    pub mantissa: i64,
    /// price = mantissa * 10^exponent
    #[prost(int32, tag = "2")]
    pub exponent: i32,
}
/// ──────────────────────────────────────────────
/// Timestamp (nanoseconds since Unix epoch)
/// ──────────────────────────────────────────────
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Timestamp {
    /// UTC nanoseconds since 1970-01-01T00:00:00Z
    #[prost(int64, tag = "1")]
    pub nanos: i64,
}
/// ──────────────────────────────────────────────
/// Reusable sub-messages
/// ──────────────────────────────────────────────
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CorrelationContext {
    #[prost(string, optional, tag = "1")]
    pub session_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub run_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub symbol: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "4")]
    pub venue: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "5")]
    pub strategy_id: ::core::option::Option<::prost::alloc::string::String>,
    /// UUID string
    #[prost(string, optional, tag = "6")]
    pub decision_id: ::core::option::Option<::prost::alloc::string::String>,
    /// UUID string
    #[prost(string, optional, tag = "7")]
    pub order_id: ::core::option::Option<::prost::alloc::string::String>,
}
/// ──────────────────────────────────────────────
/// Enums
/// ──────────────────────────────────────────────
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Side {
    Unspecified = 0,
    Buy = 1,
    Sell = 2,
}
impl Side {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SIDE_UNSPECIFIED",
            Self::Buy => "SIDE_BUY",
            Self::Sell => "SIDE_SELL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SIDE_UNSPECIFIED" => Some(Self::Unspecified),
            "SIDE_BUY" => Some(Self::Buy),
            "SIDE_SELL" => Some(Self::Sell),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Venue {
    Unspecified = 0,
    NseFut = 1,
    NseOpt = 2,
    BinancePerp = 3,
    BinanceSpot = 4,
    Paper = 5,
}
impl Venue {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "VENUE_UNSPECIFIED",
            Self::NseFut => "VENUE_NSE_FUT",
            Self::NseOpt => "VENUE_NSE_OPT",
            Self::BinancePerp => "VENUE_BINANCE_PERP",
            Self::BinanceSpot => "VENUE_BINANCE_SPOT",
            Self::Paper => "VENUE_PAPER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "VENUE_UNSPECIFIED" => Some(Self::Unspecified),
            "VENUE_NSE_FUT" => Some(Self::NseFut),
            "VENUE_NSE_OPT" => Some(Self::NseOpt),
            "VENUE_BINANCE_PERP" => Some(Self::BinancePerp),
            "VENUE_BINANCE_SPOT" => Some(Self::BinanceSpot),
            "VENUE_PAPER" => Some(Self::Paper),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum InstrumentType {
    InstrumentUnspecified = 0,
    InstrumentFut = 1,
    InstrumentCe = 2,
    InstrumentPe = 3,
    InstrumentSpread = 4,
}
impl InstrumentType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::InstrumentUnspecified => "INSTRUMENT_UNSPECIFIED",
            Self::InstrumentFut => "INSTRUMENT_FUT",
            Self::InstrumentCe => "INSTRUMENT_CE",
            Self::InstrumentPe => "INSTRUMENT_PE",
            Self::InstrumentSpread => "INSTRUMENT_SPREAD",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "INSTRUMENT_UNSPECIFIED" => Some(Self::InstrumentUnspecified),
            "INSTRUMENT_FUT" => Some(Self::InstrumentFut),
            "INSTRUMENT_CE" => Some(Self::InstrumentCe),
            "INSTRUMENT_PE" => Some(Self::InstrumentPe),
            "INSTRUMENT_SPREAD" => Some(Self::InstrumentSpread),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OrderType {
    Unspecified = 0,
    Market = 1,
    Limit = 2,
    Sl = 3,
}
impl OrderType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "ORDER_TYPE_UNSPECIFIED",
            Self::Market => "ORDER_TYPE_MARKET",
            Self::Limit => "ORDER_TYPE_LIMIT",
            Self::Sl => "ORDER_TYPE_SL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ORDER_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "ORDER_TYPE_MARKET" => Some(Self::Market),
            "ORDER_TYPE_LIMIT" => Some(Self::Limit),
            "ORDER_TYPE_SL" => Some(Self::Sl),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OrderStatus {
    Unspecified = 0,
    Pending = 1,
    Accepted = 2,
    Rejected = 3,
    PartiallyFilled = 4,
    Filled = 5,
    Cancelled = 6,
}
impl OrderStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "ORDER_STATUS_UNSPECIFIED",
            Self::Pending => "ORDER_STATUS_PENDING",
            Self::Accepted => "ORDER_STATUS_ACCEPTED",
            Self::Rejected => "ORDER_STATUS_REJECTED",
            Self::PartiallyFilled => "ORDER_STATUS_PARTIALLY_FILLED",
            Self::Filled => "ORDER_STATUS_FILLED",
            Self::Cancelled => "ORDER_STATUS_CANCELLED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ORDER_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "ORDER_STATUS_PENDING" => Some(Self::Pending),
            "ORDER_STATUS_ACCEPTED" => Some(Self::Accepted),
            "ORDER_STATUS_REJECTED" => Some(Self::Rejected),
            "ORDER_STATUS_PARTIALLY_FILLED" => Some(Self::PartiallyFilled),
            "ORDER_STATUS_FILLED" => Some(Self::Filled),
            "ORDER_STATUS_CANCELLED" => Some(Self::Cancelled),
            _ => None,
        }
    }
}
/// L1 field presence: 2-bit slot per field in MarketSnapshotV2.l1_state_bits
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FieldState {
    /// Vendor didn't send
    Absent = 0,
    /// Vendor sent null
    Null = 1,
    /// Vendor sent valid value
    Value = 2,
    /// Could not parse
    Malformed = 3,
}
impl FieldState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Absent => "FIELD_STATE_ABSENT",
            Self::Null => "FIELD_STATE_NULL",
            Self::Value => "FIELD_STATE_VALUE",
            Self::Malformed => "FIELD_STATE_MALFORMED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FIELD_STATE_ABSENT" => Some(Self::Absent),
            "FIELD_STATE_NULL" => Some(Self::Null),
            "FIELD_STATE_VALUE" => Some(Self::Value),
            "FIELD_STATE_MALFORMED" => Some(Self::Malformed),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum IntegrityTier {
    Unspecified = 0,
    /// SBE-based capture (production-grade)
    Certified = 1,
    /// JSON-based (debugging only)
    NonCertified = 2,
}
impl IntegrityTier {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "INTEGRITY_TIER_UNSPECIFIED",
            Self::Certified => "INTEGRITY_TIER_CERTIFIED",
            Self::NonCertified => "INTEGRITY_TIER_NON_CERTIFIED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "INTEGRITY_TIER_UNSPECIFIED" => Some(Self::Unspecified),
            "INTEGRITY_TIER_CERTIFIED" => Some(Self::Certified),
            "INTEGRITY_TIER_NON_CERTIFIED" => Some(Self::NonCertified),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Permission {
    Unspecified = 0,
    Approved = 1,
    Refused = 2,
}
impl Permission {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "PERMISSION_UNSPECIFIED",
            Self::Approved => "PERMISSION_APPROVED",
            Self::Refused => "PERMISSION_REFUSED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PERMISSION_UNSPECIFIED" => Some(Self::Unspecified),
            "PERMISSION_APPROVED" => Some(Self::Approved),
            "PERMISSION_REFUSED" => Some(Self::Refused),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FillType {
    Unspecified = 0,
    Full = 1,
    Partial = 2,
}
impl FillType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "FILL_TYPE_UNSPECIFIED",
            Self::Full => "FILL_TYPE_FULL",
            Self::Partial => "FILL_TYPE_PARTIAL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FILL_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "FILL_TYPE_FULL" => Some(Self::Full),
            "FILL_TYPE_PARTIAL" => Some(Self::Partial),
            _ => None,
        }
    }
}
/// Strategy signal (pre-gate). Emitted by Python strategies via scan().
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Signal {
    #[prost(string, tag = "1")]
    pub strategy_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub symbol: ::prost::alloc::string::String,
    /// "long", "short", "flat"
    #[prost(string, tag = "3")]
    pub direction: ::prost::alloc::string::String,
    /// \[0, 1\]
    #[prost(double, tag = "4")]
    pub conviction: f64,
    #[prost(enumeration = "InstrumentType", tag = "5")]
    pub instrument_type: i32,
    /// 0.0 for futures
    #[prost(double, tag = "6")]
    pub strike: f64,
    /// ISO date, empty for futures
    #[prost(string, tag = "7")]
    pub expiry: ::prost::alloc::string::String,
    /// time-to-live in bars
    #[prost(int32, tag = "8")]
    pub ttl_bars: i32,
    /// regime label at signal time
    #[prost(string, tag = "9")]
    pub regime: ::prost::alloc::string::String,
    /// human-readable explanation
    #[prost(string, tag = "10")]
    pub reasoning: ::prost::alloc::string::String,
    /// strategy-specific key-values
    #[prost(map = "string, string", tag = "11")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// Allocated target position (post-MetaAllocator, pre-gate).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TargetPosition {
    #[prost(string, tag = "1")]
    pub strategy_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub symbol: ::prost::alloc::string::String,
    /// "long", "short", "flat"
    #[prost(string, tag = "3")]
    pub direction: ::prost::alloc::string::String,
    /// portfolio weight \[0, 1\]
    #[prost(double, tag = "4")]
    pub weight: f64,
    #[prost(enumeration = "InstrumentType", tag = "5")]
    pub instrument_type: i32,
    #[prost(double, tag = "6")]
    pub strike: f64,
    #[prost(string, tag = "7")]
    pub expiry: ::prost::alloc::string::String,
    #[prost(double, tag = "8")]
    pub conviction: f64,
    #[prost(map = "string, string", tag = "9")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// Rust-side decision event (fixed-point, deterministic).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DecisionEvent {
    #[prost(message, optional, tag = "1")]
    pub ts: ::core::option::Option<Timestamp>,
    /// UUID
    #[prost(string, tag = "2")]
    pub decision_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub strategy_id: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub symbol: ::prost::alloc::string::String,
    /// "entry", "exit", "rebalance", "hold"
    #[prost(string, tag = "5")]
    pub decision_type: ::prost::alloc::string::String,
    /// +1=long, -1=short, 0=neutral
    #[prost(int32, tag = "6")]
    pub direction: i32,
    #[prost(message, optional, tag = "7")]
    pub target_qty: ::core::option::Option<FixedPoint>,
    /// mid price at decision time
    #[prost(message, optional, tag = "8")]
    pub reference_price: ::core::option::Option<FixedPoint>,
    #[prost(message, optional, tag = "9")]
    pub market_snapshot: ::core::option::Option<MarketSnapshot>,
    /// exponent=-4 (10000=1.0)
    #[prost(int64, tag = "10")]
    pub confidence_mantissa: i64,
    /// serde_json::Value as JSON string
    #[prost(string, tag = "11")]
    pub metadata_json: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "12")]
    pub ctx: ::core::option::Option<CorrelationContext>,
}
/// Versioned market snapshot at decision time.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MarketSnapshot {
    #[prost(oneof = "market_snapshot::Version", tags = "1, 2")]
    pub version: ::core::option::Option<market_snapshot::Version>,
}
/// Nested message and enum types in `MarketSnapshot`.
pub mod market_snapshot {
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Version {
        #[prost(message, tag = "1")]
        V1(super::MarketSnapshotV1),
        #[prost(message, tag = "2")]
        V2(super::MarketSnapshotV2),
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MarketSnapshotV1 {
    #[prost(int64, tag = "1")]
    pub bid_price_mantissa: i64,
    #[prost(int64, tag = "2")]
    pub ask_price_mantissa: i64,
    #[prost(int64, tag = "3")]
    pub bid_qty_mantissa: i64,
    #[prost(int64, tag = "4")]
    pub ask_qty_mantissa: i64,
    #[prost(int32, tag = "5")]
    pub price_exponent: i32,
    #[prost(int32, tag = "6")]
    pub qty_exponent: i32,
    /// exponent=-2
    #[prost(int64, tag = "7")]
    pub spread_bps_mantissa: i64,
    #[prost(int64, tag = "8")]
    pub book_ts_ns: i64,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MarketSnapshotV2 {
    #[prost(int64, tag = "1")]
    pub bid_price_mantissa: i64,
    #[prost(int64, tag = "2")]
    pub ask_price_mantissa: i64,
    #[prost(int64, tag = "3")]
    pub bid_qty_mantissa: i64,
    #[prost(int64, tag = "4")]
    pub ask_qty_mantissa: i64,
    #[prost(int32, tag = "5")]
    pub price_exponent: i32,
    #[prost(int32, tag = "6")]
    pub qty_exponent: i32,
    #[prost(int64, tag = "7")]
    pub spread_bps_mantissa: i64,
    #[prost(int64, tag = "8")]
    pub book_ts_ns: i64,
    /// 2-bit FieldState slots per field
    #[prost(uint32, tag = "9")]
    pub l1_state_bits: u32,
}
/// Order intent (pre-execution). Flows Python → Rust executor.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OrderIntent {
    #[prost(string, tag = "1")]
    pub schema_version: ::prost::alloc::string::String,
    /// nanoseconds since epoch
    #[prost(int64, tag = "2")]
    pub ts_ns: i64,
    #[prost(string, tag = "3")]
    pub session_id: ::prost::alloc::string::String,
    /// monotonic sequence
    #[prost(uint64, tag = "4")]
    pub seq: u64,
    #[prost(string, tag = "5")]
    pub strategy_id: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub symbol: ::prost::alloc::string::String,
    #[prost(enumeration = "Side", tag = "7")]
    pub side: i32,
    #[prost(enumeration = "OrderType", tag = "8")]
    pub order_type: i32,
    #[prost(message, optional, tag = "9")]
    pub quantity: ::core::option::Option<FixedPoint>,
    #[prost(message, optional, tag = "10")]
    pub limit_price: ::core::option::Option<FixedPoint>,
    #[prost(enumeration = "Permission", tag = "11")]
    pub permission: i32,
    #[prost(string, optional, tag = "12")]
    pub refuse_reason: ::core::option::Option<::prost::alloc::string::String>,
    /// UUID
    #[prost(string, tag = "13")]
    pub correlation_id: ::prost::alloc::string::String,
    /// SHA-256 hex of canonical bytes
    #[prost(string, tag = "14")]
    pub digest: ::prost::alloc::string::String,
}
/// Order status update (from broker or simulator).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OrderStatusUpdate {
    /// UUID
    #[prost(string, tag = "1")]
    pub order_id: ::prost::alloc::string::String,
    /// UUID link to originating decision
    #[prost(string, tag = "2")]
    pub parent_decision_id: ::prost::alloc::string::String,
    /// UUID
    #[prost(string, tag = "3")]
    pub intent_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "4")]
    pub ts: ::core::option::Option<Timestamp>,
    #[prost(string, tag = "5")]
    pub symbol: ::prost::alloc::string::String,
    #[prost(enumeration = "Side", tag = "6")]
    pub side: i32,
    #[prost(enumeration = "OrderStatus", tag = "7")]
    pub status: i32,
    #[prost(double, tag = "8")]
    pub filled_quantity: f64,
    #[prost(double, tag = "9")]
    pub avg_price: f64,
    #[prost(double, tag = "10")]
    pub commission: f64,
    #[prost(string, tag = "11")]
    pub broker_order_id: ::prost::alloc::string::String,
    #[prost(string, tag = "12")]
    pub rejection_reason: ::prost::alloc::string::String,
    /// "NRML", "MIS", etc.
    #[prost(string, tag = "13")]
    pub product_type: ::prost::alloc::string::String,
}
/// Execution fill (from broker or simulator).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecutionFill {
    #[prost(string, tag = "1")]
    pub schema_version: ::prost::alloc::string::String,
    /// nanoseconds since epoch
    #[prost(int64, tag = "2")]
    pub ts_ns: i64,
    #[prost(string, tag = "3")]
    pub session_id: ::prost::alloc::string::String,
    /// monotonic sequence
    #[prost(uint64, tag = "4")]
    pub seq: u64,
    #[prost(uint64, optional, tag = "5")]
    pub parent_intent_seq: ::core::option::Option<u64>,
    #[prost(string, tag = "6")]
    pub strategy_id: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub symbol: ::prost::alloc::string::String,
    #[prost(enumeration = "Side", tag = "8")]
    pub side: i32,
    #[prost(message, optional, tag = "9")]
    pub quantity: ::core::option::Option<FixedPoint>,
    #[prost(message, optional, tag = "10")]
    pub price: ::core::option::Option<FixedPoint>,
    #[prost(message, optional, tag = "11")]
    pub fee: ::core::option::Option<FixedPoint>,
    #[prost(string, tag = "12")]
    pub venue: ::prost::alloc::string::String,
    /// UUID
    #[prost(string, tag = "13")]
    pub correlation_id: ::prost::alloc::string::String,
    #[prost(enumeration = "FillType", tag = "14")]
    pub fill_type: i32,
    /// SHA-256 hex of canonical bytes
    #[prost(string, tag = "15")]
    pub digest: ::prost::alloc::string::String,
    #[prost(string, tag = "16")]
    pub fill_id: ::prost::alloc::string::String,
    /// UUID
    #[prost(string, tag = "17")]
    pub order_id: ::prost::alloc::string::String,
    /// UUID
    #[prost(string, optional, tag = "18")]
    pub parent_decision_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "19")]
    pub commission_asset: ::prost::alloc::string::String,
    /// true if order fully filled
    #[prost(bool, tag = "20")]
    pub is_final: bool,
}
/// Single instrument position.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PositionUpdate {
    #[prost(string, tag = "1")]
    pub symbol: ::prost::alloc::string::String,
    #[prost(double, tag = "2")]
    pub quantity: f64,
    #[prost(double, tag = "3")]
    pub avg_price: f64,
    #[prost(double, tag = "4")]
    pub unrealized_pnl: f64,
    #[prost(string, tag = "5")]
    pub strategy_id: ::prost::alloc::string::String,
    /// "long", "short", "flat"
    #[prost(string, tag = "6")]
    pub direction: ::prost::alloc::string::String,
    /// portfolio weight
    #[prost(double, tag = "7")]
    pub weight: f64,
}
/// Full portfolio snapshot (periodic).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PortfolioSnapshot {
    #[prost(message, optional, tag = "1")]
    pub ts: ::core::option::Option<Timestamp>,
    #[prost(double, tag = "2")]
    pub total_equity: f64,
    #[prost(double, tag = "3")]
    pub peak_equity: f64,
    #[prost(double, tag = "4")]
    pub cash: f64,
    #[prost(double, tag = "5")]
    pub margin_used: f64,
    #[prost(double, tag = "6")]
    pub portfolio_dd: f64,
    #[prost(double, tag = "7")]
    pub total_exposure: f64,
    #[prost(double, tag = "8")]
    pub vpin: f64,
    #[prost(int32, tag = "9")]
    pub position_count: i32,
    #[prost(string, tag = "10")]
    pub regime: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "11")]
    pub positions: ::prost::alloc::vec::Vec<PositionUpdate>,
    #[prost(map = "string, double", tag = "12")]
    pub strategy_equity: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        f64,
    >,
    #[prost(map = "string, double", tag = "13")]
    pub strategy_dd: ::std::collections::HashMap<::prost::alloc::string::String, f64>,
    #[prost(string, repeated, tag = "14")]
    pub active_breakers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Position key for lookups.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PositionKey {
    #[prost(string, tag = "1")]
    pub strategy_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub symbol: ::prost::alloc::string::String,
    #[prost(enumeration = "InstrumentType", tag = "3")]
    pub instrument_type: i32,
    #[prost(double, tag = "4")]
    pub strike: f64,
    #[prost(string, tag = "5")]
    pub expiry: ::prost::alloc::string::String,
}
/// Raw market tick.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Tick {
    #[prost(int64, tag = "1")]
    pub instrument_token: i64,
    /// last traded price
    #[prost(double, tag = "2")]
    pub ltp: f64,
    #[prost(int64, tag = "3")]
    pub volume: i64,
    /// open interest
    #[prost(int64, tag = "4")]
    pub oi: i64,
    #[prost(double, tag = "5")]
    pub bid: f64,
    #[prost(double, tag = "6")]
    pub ask: f64,
    #[prost(int64, tag = "7")]
    pub bid_qty: i64,
    #[prost(int64, tag = "8")]
    pub ask_qty: i64,
}
/// 1-minute OHLCV bar.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Bar1m {
    #[prost(double, tag = "1")]
    pub open: f64,
    #[prost(double, tag = "2")]
    pub high: f64,
    #[prost(double, tag = "3")]
    pub low: f64,
    #[prost(double, tag = "4")]
    pub close: f64,
    #[prost(int64, tag = "5")]
    pub volume: i64,
    #[prost(int64, tag = "6")]
    pub oi: i64,
    #[prost(double, tag = "7")]
    pub vwap: f64,
    /// ISO timestamp for bar open
    #[prost(string, tag = "8")]
    pub bar_ts: ::prost::alloc::string::String,
}
/// L1 quote (fixed-point, from Rust data crate).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QuoteEvent {
    #[prost(message, optional, tag = "1")]
    pub ts: ::core::option::Option<Timestamp>,
    #[prost(string, tag = "2")]
    pub symbol: ::prost::alloc::string::String,
    #[prost(int64, tag = "3")]
    pub bid_price_mantissa: i64,
    #[prost(int64, tag = "4")]
    pub ask_price_mantissa: i64,
    #[prost(int64, tag = "5")]
    pub bid_qty_mantissa: i64,
    #[prost(int64, tag = "6")]
    pub ask_qty_mantissa: i64,
    #[prost(int32, tag = "7")]
    pub price_exponent: i32,
    #[prost(int32, tag = "8")]
    pub qty_exponent: i32,
    #[prost(string, tag = "9")]
    pub venue: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "10")]
    pub ctx: ::core::option::Option<CorrelationContext>,
}
/// L2 depth level.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DepthLevel {
    #[prost(int64, tag = "1")]
    pub price_mantissa: i64,
    #[prost(int64, tag = "2")]
    pub qty_mantissa: i64,
}
/// L2 depth event.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DepthEvent {
    #[prost(message, optional, tag = "1")]
    pub ts: ::core::option::Option<Timestamp>,
    #[prost(string, tag = "2")]
    pub tradingsymbol: ::prost::alloc::string::String,
    #[prost(uint64, tag = "3")]
    pub first_update_id: u64,
    #[prost(uint64, tag = "4")]
    pub last_update_id: u64,
    #[prost(int32, tag = "5")]
    pub price_exponent: i32,
    #[prost(int32, tag = "6")]
    pub qty_exponent: i32,
    #[prost(message, repeated, tag = "7")]
    pub bids: ::prost::alloc::vec::Vec<DepthLevel>,
    #[prost(message, repeated, tag = "8")]
    pub asks: ::prost::alloc::vec::Vec<DepthLevel>,
    #[prost(bool, tag = "9")]
    pub is_snapshot: bool,
    #[prost(enumeration = "IntegrityTier", tag = "10")]
    pub integrity_tier: i32,
    #[prost(string, optional, tag = "11")]
    pub source: ::core::option::Option<::prost::alloc::string::String>,
}
/// Gate decision (result of risk check on a signal).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GateDecision {
    /// sequence of upstream Signal event
    #[prost(uint64, tag = "1")]
    pub signal_seq: u64,
    #[prost(enumeration = "GateResult", tag = "2")]
    pub gate: i32,
    #[prost(bool, tag = "3")]
    pub approved: bool,
    #[prost(double, tag = "4")]
    pub adjusted_weight: f64,
    #[prost(string, tag = "5")]
    pub reason: ::prost::alloc::string::String,
    #[prost(double, tag = "6")]
    pub vpin: f64,
    #[prost(double, tag = "7")]
    pub portfolio_dd: f64,
    #[prost(double, tag = "8")]
    pub strategy_dd: f64,
    #[prost(double, tag = "9")]
    pub total_exposure: f64,
}
/// Risk alert (breaker, VPIN, drawdown).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RiskAlert {
    /// "vpin_toxic", "dd_portfolio", "breaker_on", etc.
    #[prost(string, tag = "1")]
    pub alert_type: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub previous_state: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub new_state: ::prost::alloc::string::String,
    #[prost(double, tag = "4")]
    pub threshold: f64,
    #[prost(double, tag = "5")]
    pub current_value: f64,
    #[prost(string, tag = "6")]
    pub detail: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "7")]
    pub symbol: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "8")]
    pub strategy_id: ::core::option::Option<::prost::alloc::string::String>,
}
/// Risk limits configuration.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RiskLimits {
    /// default 0.05
    #[prost(double, tag = "1")]
    pub max_portfolio_dd: f64,
    /// default 0.03
    #[prost(double, tag = "2")]
    pub max_strategy_dd: f64,
    /// default 0.20
    #[prost(double, tag = "3")]
    pub max_single_instrument: f64,
    /// default 0.05
    #[prost(double, tag = "4")]
    pub max_single_stock_fno: f64,
    /// default 0.70
    #[prost(double, tag = "5")]
    pub vpin_block_threshold: f64,
    /// default 1.50
    #[prost(double, tag = "6")]
    pub max_total_exposure: f64,
    /// default 0.40
    #[prost(double, tag = "7")]
    pub max_correlated_exposure: f64,
}
/// Strategy circuit breaker state.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CircuitBreakerState {
    #[prost(string, tag = "1")]
    pub strategy_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub is_open: bool,
    #[prost(uint32, tag = "3")]
    pub consecutive_losses: u32,
    #[prost(uint32, tag = "4")]
    pub loss_threshold: u32,
    /// nanoseconds since epoch
    #[prost(int64, optional, tag = "5")]
    pub opened_at_ns: ::core::option::Option<i64>,
    #[prost(uint64, tag = "6")]
    pub cooldown_secs: u64,
    #[prost(double, tag = "7")]
    pub daily_pnl: f64,
    #[prost(double, tag = "8")]
    pub daily_loss_limit: f64,
}
/// Risk gate result enum.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum GateResult {
    Unspecified = 0,
    Pass = 1,
    BlockVpin = 2,
    BlockDdPortfolio = 3,
    BlockDdStrategy = 4,
    BlockConcentration = 5,
    BlockExposure = 6,
    ReduceSize = 7,
}
impl GateResult {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "GATE_RESULT_UNSPECIFIED",
            Self::Pass => "GATE_RESULT_PASS",
            Self::BlockVpin => "GATE_RESULT_BLOCK_VPIN",
            Self::BlockDdPortfolio => "GATE_RESULT_BLOCK_DD_PORTFOLIO",
            Self::BlockDdStrategy => "GATE_RESULT_BLOCK_DD_STRATEGY",
            Self::BlockConcentration => "GATE_RESULT_BLOCK_CONCENTRATION",
            Self::BlockExposure => "GATE_RESULT_BLOCK_EXPOSURE",
            Self::ReduceSize => "GATE_RESULT_REDUCE_SIZE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "GATE_RESULT_UNSPECIFIED" => Some(Self::Unspecified),
            "GATE_RESULT_PASS" => Some(Self::Pass),
            "GATE_RESULT_BLOCK_VPIN" => Some(Self::BlockVpin),
            "GATE_RESULT_BLOCK_DD_PORTFOLIO" => Some(Self::BlockDdPortfolio),
            "GATE_RESULT_BLOCK_DD_STRATEGY" => Some(Self::BlockDdStrategy),
            "GATE_RESULT_BLOCK_CONCENTRATION" => Some(Self::BlockConcentration),
            "GATE_RESULT_BLOCK_EXPOSURE" => Some(Self::BlockExposure),
            "GATE_RESULT_REDUCE_SIZE" => Some(Self::ReduceSize),
            _ => None,
        }
    }
}
/// Canonical event envelope. All events are wrapped in this container.
/// JSON serde (sorted keys, compact separators) remains for WAL/audit trail.
/// Protobuf encoding is used ONLY for the live Python<->Rust signal boundary.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventEnvelope {
    /// UTC ISO-8601 (microsecond precision)
    #[prost(string, tag = "1")]
    pub ts: ::prost::alloc::string::String,
    /// monotonic sequence number per run
    #[prost(uint64, tag = "2")]
    pub seq: u64,
    /// stable session identifier
    #[prost(string, tag = "3")]
    pub run_id: ::prost::alloc::string::String,
    /// EventType string value
    #[prost(string, tag = "4")]
    pub event_type: ::prost::alloc::string::String,
    /// engine module name
    #[prost(string, tag = "5")]
    pub source: ::prost::alloc::string::String,
    /// empty for market-only events
    #[prost(string, tag = "6")]
    pub strategy_id: ::prost::alloc::string::String,
    /// empty where irrelevant
    #[prost(string, tag = "7")]
    pub symbol: ::prost::alloc::string::String,
    #[prost(
        oneof = "event_envelope::Payload",
        tags = "10, 11, 12, 13, 14, 15, 16, 17, 18, 19"
    )]
    pub payload: ::core::option::Option<event_envelope::Payload>,
}
/// Nested message and enum types in `EventEnvelope`.
pub mod event_envelope {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Payload {
        #[prost(message, tag = "10")]
        Tick(super::Tick),
        #[prost(message, tag = "11")]
        Bar1m(super::Bar1m),
        #[prost(message, tag = "12")]
        Signal(super::Signal),
        #[prost(message, tag = "13")]
        GateDecision(super::GateDecision),
        #[prost(message, tag = "14")]
        Order(super::OrderIntent),
        #[prost(message, tag = "15")]
        Fill(super::ExecutionFill),
        #[prost(message, tag = "16")]
        RiskAlert(super::RiskAlert),
        #[prost(message, tag = "17")]
        Snapshot(super::PortfolioSnapshot),
        #[prost(message, tag = "18")]
        Position(super::PositionUpdate),
        #[prost(message, tag = "19")]
        Decision(super::DecisionEvent),
    }
}
/// Batch of envelopes (for bulk transfer).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventBatch {
    #[prost(message, repeated, tag = "1")]
    pub events: ::prost::alloc::vec::Vec<EventEnvelope>,
}
